---
title: "Financial Analytics - Trabalho Final"
authors:
  - name: Michel Maurice Conjaud
  - name: Hélio Pereira Oliveira
  - name: Renan Cabral
  - name: Tiago Evangelista Pardo
format:
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cerulean
    toc: true
    toc-expand: true
    toc-title: "Sumário"
    toc_float: true

execute:
  freeze: true
  warning: false
  cache: true
---

# 0. Bibliotecas e Importação de Dados

Bibliotecas
```{r}
#| output: false
library(ggplot2)
library(fpp3)
library(rugarch)
library(tsibble)
library(yfR)
library(zoo)
library(xts)
library(lubridate)
library(patchwork)
library(lmtest)
library(fGarch)
library(xts)
```






Seleção das Ações/Ativos e definição da data de início: 01/01/2019
```{r}

start_date <- '2019-01-01'

ativos <- c(
  "NVDC34.SA",
  "BCSA34.SA", 
  "AMZO34.SA",
  "RENT3.SA",
  "PRIO3.SA",
  "TASA4.SA"
)
```

Selecionando ações e transformando dataframe em tsbible 

```{r}
#| output: false
da <- yfR::yf_get(
  ativos,
  first_date = start_date,
  last_date = Sys.Date(),
  bench_ticker = "^BVSP",
  type_return = "log",
  freq_data = "daily",
  do_complete_data = TRUE
)

# da_tsibble <- da |>
#   as_tsibble(key = ticker, index = ref_date, regular = FALSE)
  
```



```{r}
# Capturando menor data da base 
data_corte <- da |>
  dplyr::group_by(ticker) |>
  dplyr::filter(ref_date == min(ref_date)) |>
  dplyr::ungroup() |>
  with(max(ref_date))

data_corte
```


```{r}
# Df com data mínima
da_train <- da |>
  dplyr::filter(ref_date > data_corte) 

view(da_train)  
```

```{r}
#| output: false

da_tsibble <- da_train |>
  as_tsibble(key = ticker, index = ref_date, regular = FALSE)
```


# 1. Gráficos de Preço, Retorno e Avaliação de Heterodasticidade Condicional

## 1.1. Gráfico de preços e dos log retornos

### 1.1.1. Preços
```{r}

#Função para formatar legenda
quarter_label <- function(x) {
  paste0(year(x), "Q", quarter(x))
}  
```

```{r}
#| fig-width: 7
#| fig-height: 10

#criando gráfico da série de preços
da_tsibble |>
  autoplot(price_adjusted, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1)+
  scale_x_date(date_breaks = "3 months", label=quarter_label) +
  labs ( title = "Série de Preço", y = "Preço", x = "Data") +
  theme(
    plot.title = element_text(hjust = .5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )
```  

### 1.1.2. Log Retornos
```{r}
#| fig-width: 7
#| fig-height: 10
#| 
#criando gráfico da série de retornos
da_tsibble |>
  autoplot(ret_adjusted_prices, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1) +
  scale_x_date(date_breaks = "3 months", labels = quarter_label) +
  labs ( title = "Série de Log Retornos", y = "Log Retornos", x = "Data") +
  theme(plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )

```

## 1.2 Analisando possível heterocedasticidade condicional

Criação do log retorno ao quadrado (proxi da volatilidade)

```{r}
#| fig-width: 7
#| fig-height: 10

da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2) |>
  autoplot(ret2, colour = "black") +
  facet_wrap(~ticker, ncol = 1)
```

**Verificando a existência de heterodasticidade condicional através dos seguintes métodos:**

* 1.2.1. ACF dos retornos quadráticos

* 1.2.2. Teste Ljung-Box dos retornos quadráticos

* 1.2.3. Teste Langrange Multiplier

### 1.2.1. ACF dos retornos ao quadrado

```{r}
# Gerando variável dos retornos quadráticos
da_tsibble  <-  da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2)
```

```{r}
#ACF dos retornos ao quadrado
da_tsibble |>
  ACF(ret2) |>
  autoplot()
```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INSERIR CONCLUSÃO AQUI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 1.2.2. Teste Ljung-Box
```{r}

resultados <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)
  
  # Realizar o teste Box-Ljung
  box_test_result <- Box.test(da_tsibble_filtered$ret2, type = "Ljung-Box")
  
  # Adicionar o resultado ao dataframe de resultados
  resultados <- rbind(resultados, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = box_test_result$p.value 
                                          ))
}

print(resultados)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, RENT3.SA, PRIO3.SA e TASA4.SA, AMZO34.SA

### 1.2.3. Teste Lagrange Multiplier
```{r}
library(FinTS)

resultados_ml <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)

  teste_ml <- ArchTest(da_tsibble_filtered$ret_closing_prices)

  # Adicionar o resultado ao dataframe de resultados
  resultados_ml <- rbind(resultados_ml, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = teste_ml$p.value 
                                          ))
}

print(resultados_ml)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, AMZO34.SA, RENT3.SA, PRIO3.SA, e TASA4.SA

# 2. Ajustando modelos

## 2.1. Ajuste

```{r}
# Lista para comparação de modelos
modelos_garch <- list()
ics_modelos_garch  <- list()
resultados_tidy <- list()

distribuicao_erro  <- c("norm", "std")

  for (empresa in unique(da_tsibble$ticker)) {
    retornos <- da_tsibble %>%
    subset(ticker== empresa) %>%
    select(ref_date,ret_closing_prices)
  ret <- xts(retornos[,-1],order.by = ymd(retornos$ref_date))[-1,]
  ret2 = ret**2
  plot(ret2)

    # Loop pelos parâmetros de tipo de distribuição e m e n
    for (distribuicao in distribuicao_erro) {
      for (m in 1:3) {
        for (n in 0:3) {
        
          # Definir a fórmula do modelo com os parâmetros m e n atuais
          formula_garch <- paste0("~garch(", m, ",", n, ")")

          # Ajustar o modelo GARCH
          modelo_atual <- garchFit(formula = as.formula(formula_garch), data = ret, trace = FALSE, 
                                   include.mean = TRUE, cond.dist = distribuicao)

          # Armazenar o modelo ajustado na lista para visualização detalhada
          modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual
          # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
          ics_modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual@fit$ics
        }
      }
    }

    # Formatando resultados para melhor visualização 

    for (nome_modelo in names(ics_modelos_garch)) {
      valores <- ics_modelos_garch[[nome_modelo]]
      df <- data.frame(
        AIC = valores["AIC"],
        BIC = valores["BIC"]
      )
        resultados_tidy[[nome_modelo]] <- df
    }
    } 
    resultados_tidy_df <- do.call(rbind, resultados_tidy)

resultados_tidy_df  %>% rownames_to_column()  %>% 
                          separate(rowname, c("Modelo", "m", "n", "dist", "ticker"),
                          sep = "_")  %>% 
                          arrange(AIC)  %>% 
                          distinct(ticker, .keep_all = TRUE)

```

## 2.2. Análise dos resíduos
```{r}
# residuos  <- residuals(modelos_garch$garch_1_1_std, standardize=T)
# par(mfrow=c(1,2))
# ts.plot(residuos)
# acf(residuos)
```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!INSERIR CONCLUSÃO AQUI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# 3. Previsão dos Ativos (HELIO)

```{r}
# forecast <- predict(modelos_garch$garch_1_1_std, n.ahead = 1)
# forecast
```

```{r}
# # Criação inicial do data frame vazio
# comparacao_forecast <- data.frame(Empresa = character(), meanForecast = double(), meanError = double(), standardDeviation = double())

# # Adicionando os resultados da previsão para a "Amazon" ao data frame
# comparacao_forecast <- rbind(comparacao_forecast, 
#                              data.frame(Empresa = "Santander",
#                                         meanForecast = forecast$meanForecast,
#                                         meanError = forecast$meanError,
#                                         standardDeviation = forecast$standardDeviation))
```

# 4. Escolha de Portfólio (TIAGO)

## 4.1. Pesos dos ativos

 ```{r}
# library(tidyquant)
# pesos_finais  <- c(0.10, 0.20, 0.20, 0.10, 0.20, 0.20) %>% 
#   setNames(ativos)

```


```{r}

# portfolio  <- da_tsibble  %>% 
#                 select(ticker, ret_closing_prices)
#                 # pivot_wider(names_from = ticker, values_from = ret_closing_prices)

# retornos_portfolio <- portfolio |>
#   ungroup() %>% 
#   as_tibble() %>% 
#   tidyquant::tq_portfolio(
#     ticker,
#     ret_closing_prices,
#     weights = pesos_finais,
#     col_rename = "portfolio"
#   )

# retornos_portfolio

```

# Calcular retorno do portfólio (MICHEL)


# Otimizar o retorno portfólio 