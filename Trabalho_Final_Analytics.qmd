---
title: "Financial Analytics - Trabalho Final"
authors:
  - name: Michel Maurice Conjaud
  - name: Hélio Pereira Oliveira
  - name: Renan Cabral
  - name: Tiago Evangelista Pardo
format:
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cerulean
    toc: true
    toc-expand: true
    toc-title: "Sumário"
    toc_float: true

execute:
  freeze: true
  warning: false
  cache: true
---

# 0. Bibliotecas e Importação de Dados

Bibliotecas
```{r}
#| output: false
library(ggplot2)
library(fpp3)
library(rugarch)
library(tsibble)
library(yfR)
library(zoo)
library(xts)
library(lubridate)
library(patchwork)
library(lmtest)
library(fGarch)
library(xts)
library(FinTS)
library(tidyquant)
library(plotly)
library(timetk)
```


Seleção das Ações/Ativos e definição da data de início: 01/01/2019
```{r}
#| output: false

data_inicio <- '2019-01-01'

ativos <- c(
  "NVDC34.SA",
  "BCSA34.SA", 
  "AMZO34.SA",
  "RENT3.SA",
  "PRIO3.SA",
  "TASA4.SA"
)

# Importando base da API do Yahoo
da <- yfR::yf_get(
    ativos,
    first_date = data_inicio,
    last_date = Sys.Date(),
    bench_ticker = "^BVSP",
    type_return = "log",
    freq_data = "daily",
    do_complete_data = TRUE
)    %>% 
    select( ticker, ref_date, price_adjusted, ret_closing_prices )
 
        
# Capturando menor data da base 
data_corte <- da |>
  dplyr::group_by(ticker) |>
  dplyr::filter(ref_date == min(ref_date)) |>
  dplyr::ungroup() |>
  with(max(ref_date))

# Filtrando base com data mínima
da_train <- da |>
  dplyr::filter(ref_date > data_corte) 

# Transformando em Tsibble
da_tsibble <- da_train |>
  as_tsibble(key = ticker, index = ref_date, regular = FALSE)
```


# 1. Gráficos de Preço, Retorno e Avaliação de Heterodasticidade Condicional

## 1.1. Gráfico de preços


```{r}

#Função para formatar legenda
quarter_label <- function(x) {
  paste0(year(x), "Q", quarter(x))
}  
```

```{r}
#| fig-width: 7
#| fig-height: 10

#criando gráfico da série de preços
da_tsibble |>
  autoplot(price_adjusted, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1)+
  scale_x_date(date_breaks = "3 months", label=quarter_label) +
  labs ( title = "Série de Preço", y = "Preço", x = "Data") +
  theme(
    plot.title = element_text(hjust = .5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )
```  

## 1.2. Log Retornos

```{r}
#| fig-width: 7
#| fig-height: 10
#| 
#criando gráfico da série de retornos
da_tsibble |>
  autoplot(ret_adjusted_prices, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1) +
  scale_x_date(date_breaks = "3 months", labels = quarter_label) +
  labs ( title = "Série de Log Retornos", y = "Log Retornos", x = "Data") +
  theme(plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )

```

## 1.3 Avaliando heterocedasticidade condicional

Criação do log retorno ao quadrado (proxi da volatilidade)

```{r}
#| fig-width: 7
#| fig-height: 10

da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2) |>
  autoplot(ret2, colour = "black") +
  facet_wrap(~ticker, ncol = 1)

```

**Verificando a existência de heterodasticidade condicional através dos seguintes métodos:**

* 1.2.1. ACF dos retornos quadráticos

* 1.2.2. Teste Ljung-Box dos retornos quadráticos

* 1.2.3. Teste Langrange Multiplier

### 1.2.1. ACF dos retornos ao quadrado

```{r}
# Gerando variável dos retornos quadráticos
da_tsibble  <-  da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2)
```

```{r}
#| fig-width: 7
#| fig-height: 10

#ACF dos retornos ao quadrado
da_tsibble |>
  ACF(ret2) |>
  autoplot()
```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INSERIR CONCLUSÃO AQUI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 1.2.2. Teste Ljung-Box
```{r}

resultados <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)
  
  # Realizar o teste Box-Ljung
  box_test_result <- Box.test(da_tsibble_filtered$ret2, type = "Ljung-Box")
  
  # Adicionar o resultado ao dataframe de resultados
  resultados <- rbind(resultados, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = box_test_result$p.value 
                                          ))
}

print(resultados)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, RENT3.SA, PRIO3.SA e TASA4.SA, AMZO34.SA

### 1.2.3. Teste Lagrange Multiplier
```{r}


resultados_ml <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)

  teste_ml <- ArchTest(da_tsibble_filtered$ret_closing_prices)

  # Adicionar o resultado ao dataframe de resultados
  resultados_ml <- rbind(resultados_ml, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = teste_ml$p.value 
                                          ))
}

print(resultados_ml)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, AMZO34.SA, RENT3.SA, PRIO3.SA, e TASA4.SA

# 2. Ajustando modelos Arch / Garch

## 2.1. Ajuste

```{r}
# Lista para comparação de modelos
modelos_garch <- list()
ics_modelos_garch  <- list()
resultados_tidy <- list()

distribuicao_erro  <- c("norm", "std")

for (empresa in unique(da_tsibble$ticker)) {
  retornos <- da_tsibble %>%
  subset(ticker== empresa) %>%
  select(ref_date,ret_closing_prices)
ret <- xts(retornos[,-1],order.by = ymd(retornos$ref_date))[-1,]
ret2 = ret**2
  # Loop pelos parâmetros de tipo de distribuição e m e n
  for (distribuicao in distribuicao_erro) {
    for (m in 1:3) {
      for (n in 0:3) {
      
        # Definir a fórmula do modelo com os parâmetros m e n atuais
        formula_garch <- paste0("~garch(", m, ",", n, ")")
        # Ajustar o modelo GARCH
        modelo_atual <- garchFit(formula = as.formula(formula_garch), data = ret, trace = FALSE, 
                                 include.mean = TRUE, cond.dist = distribuicao)
        # Armazenar o modelo ajustado na lista para visualização detalhada
        modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual
        # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
        ics_modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual@fit$ics
    }
  }
}
  # Formatando resultados para melhor visualização 
  for (nome_modelo in names(ics_modelos_garch)) {
    valores <- ics_modelos_garch[[nome_modelo]]
    df <- data.frame(
      AIC = valores["AIC"],
      BIC = valores["BIC"]
    )
      resultados_tidy[[nome_modelo]] <- df
  }
} 

resultados_tidy_df <- do.call(rbind, resultados_tidy) %>% 
  rownames_to_column()  %>% 
    separate(rowname, c("Modelo", "m", "n", "dist", "ticker"),
    sep = "_")  %>% 
    arrange(AIC)  %>% 
    distinct(ticker, .keep_all = TRUE)

```

## 2.2. Análise dos resíduos
```{r}
residuos <- list()

for (i in 1:nrow(resultados_tidy_df)) {
  # Concatenando o nome do modelo para ficar como consta no objeto modelos_garch
  model_name <- paste0(resultados_tidy_df$Modelo[i], "_", resultados_tidy_df$m[i], "_", resultados_tidy_df$n[i], "_", resultados_tidy_df$dist[i], "_", resultados_tidy_df$ticker[i])
  
  # Checando se o modelo está entre os melhores
  if (model_name %in% names(modelos_garch)) {
    # Acessando os melhores modelos e calculando resíduos
    current_model <- modelos_garch[[model_name]]
    residuos[[model_name]] <- residuals(current_model, standardize = TRUE)
  }
}
str(residuos)

```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!INSERIR CONCLUSÃO AQUI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# 3. Previsão dos Ativos (HELIO)

```{r}
# forecast <- predict(modelos_garch$garch_1_1_std, n.ahead = 1)
# forecast
```

```{r}
# # Criação inicial do data frame vazio
# comparacao_forecast <- data.frame(Empresa = character(), meanForecast = double(), meanError = double(), standardDeviation = double())

# # Adicionando os resultados da previsão para a "Amazon" ao data frame
# comparacao_forecast <- rbind(comparacao_forecast, 
#                              data.frame(Empresa = "Santander",
#                                         meanForecast = forecast$meanForecast,
#                                         meanError = forecast$meanError,
#                                         standardDeviation = forecast$standardDeviation))
```

```{r}

model_names <- c(
  "garch_1_2_std_AMZO34.SA",
  "garch_1_1_std_BCSA34.SA",
  "garch_1_1_std_PRIO3.SA",
  "garch_1_1_std_NVDC34.SA",
  "garch_1_1_std_TASA4.SA",
  "garch_1_1_std_BCSA34.SA"
)
titles <- c(
  "Volatilidade AMZO34.SA",
  "Volatilidade BCSA34.SA",
  "Volatilidade PRIO3.SA",
  "Volatilidade NVDC34.SA",
  "Volatilidade TASA4.SA",
  "Volatilidade BCSA34.SA"
)

par(mfrow = c(6, 1)) 

sigma  <-  list()
for (i in 1:length(model_names)) {
  model_name <- model_names[i]
  title <- titles[i]
  
  model <- modelos_garch[[model_name]]
  sigma <- cbind(model@sigma.t) 
  
  print(plot(model@sigma.t, main = title))
  }
```

# 4. Portfólio

## 4.1. Retorno ponderado, Risco e Ratio

```{r}

pesos  <- c(0.10, 0.20, 0.20, 0.10, 0.20, 0.20) %>% 
  setNames(ativos)

portfolio  <- da_tsibble  %>% 
                select(ticker, ret_closing_prices)

retorno_ponderado_portfolio <- portfolio |>
  ungroup() %>% 
  as_tibble() %>% 
  tidyquant::tq_portfolio(
    ticker,
    ret_closing_prices,
    weights = pesos,
    col_rename = "retornos"
  )

media_retornos  <-  round(mean(retorno_ponderado_portfolio$retornos),7)

paste0("Média dos retornos do portfólio: ", media_retornos)

```

## 4.2. Modelagem Garch do Portfolio
```{r}
modelos_garch_portfolio <- list()
ics_modelos_garch_portfolio  <- list()
resultados_tidy_portfolio <- list()


for (distribuicao in distribuicao_erro) {
  for (m in 1:3) {
    for (n in 0:3) {
    
      # Definir a fórmula do modelo com os parâmetros m e n atuais
      formula_garch <- paste0("~garch(", m, ",", n, ")")

      # Ajustar o modelo GARCH
      modelo_atual <- garchFit(
        formula = as.formula(formula_garch),
        data = retornos_portfolio$Retornos,
        trace = FALSE,          
        include.mean = TRUE, 
        cond.dist = distribuicao)

      # Armazenar o modelo ajustado na lista para visualização detalhada
      modelos_garch_portfolio[[paste0("garch_", m, "_", n, "_", distribuicao)]] <- modelo_atual
      
      # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
      ics_modelos_garch_portfolio[[paste0("garch_", m, "_", n, "_", distribuicao)]] <- modelo_atual@fit$ics
    }
  }
}
# Formatando resultados para melhor visualização 
  for (nome_modelo in names(ics_modelos_garch_portfolio)) {
    valores <- ics_modelos_garch_portfolio[[nome_modelo]]
    df <- data.frame(
      AIC = valores["AIC"],
      BIC = valores["BIC"]
    )
      resultados_tidy_portfolio[[nome_modelo]] <- df
}

resultados_tidy_df_portfolio <- do.call(rbind, resultados_tidy_portfolio)%>% 
  rownames_to_column()  %>% 

    arrange(AIC)  %>% 
    slice(1)

resultados_tidy_df_portfolio
```

## 4.3. Forecast do Portfólio

```{r}
forecast <- predict(modelos_garch_portfolio$garch_1_1_std, n.ahead = 1)
forecast
```

# 5. CAPM Portfólio

Bases de retornos do mercado (Ibovespa)
```{r}
#| output: false

retornos_mercado_log  <- yfR::yf_get(
    '^BVSP',
    first_date = data_inicio,
    last_date = Sys.Date(),
    bench_ticker = "^BVSP",
    type_return = "log",
    freq_data = "daily",
    do_complete_data = TRUE
    )  %>% 
    select(ref_date, ret_closing_prices)  %>%
    filter(ref_date > data_corte)  %>%  
    na.omit()  %>% 
    distinct(ref_date, .keep_all = TRUE)


retornos_mercado_arit  <- yfR::yf_get(
    '^BVSP',
    first_date = data_inicio,
    last_date = Sys.Date(),
    bench_ticker = "^BVSP",
    type_return = "arit",
    freq_data = "daily",
    do_complete_data = TRUE
    )  %>% 
    select(ref_date, ret_closing_prices)  %>%
    filter(ref_date > data_corte)  %>%  
    na.omit()  %>% 
    distinct(ref_date, .keep_all = TRUE)


retornos_carteira_arit <- yfR::yf_get(
    ativos,
    first_date = data_inicio,
    last_date = Sys.Date(),
    bench_ticker = "^BVSP",
    type_return = "arit",
    freq_data = "daily",
    do_complete_data = TRUE
    ) %>% 
    select( ref_date, ret_closing_prices )  %>% 
    na.omit()

```

## Betas individuais por ativo  
```{r}
betas <- list() # Inicializa a lista para armazenar os betas

for (empresa in ativos) {
  # Filtra o dataframe para a empresa atual no loop
  da_tsibble_filtrado <- da_tsibble %>% 
    filter(ticker == empresa)
  
  # Calcula o modelo linear
  modelo_lm <- lm(ret_closing_prices ~ retornos_mercado_log$ret_closing_prices, data = da_tsibble_filtrado)
  
  # Extrai o coeficiente beta e armazena na lista
  betas[[empresa]] <- coef(modelo_lm)["retornos_mercado_log$ret_closing_prices"]
}

# transforma a lista de betas em um dataframe ou tibble
betas_df <- tibble(empresa = names(betas), beta = unlist(betas))

print(betas_df)
```

##  ARRUMAR AQUI DEVE ESTAR ERRADO Retorno ponderado do Portfólio
```{r}
betas_ponderados <- betas_df$beta * pesos[betas_df$empresa]
somatorio_betas_ponderados <- sum(betas_ponderados)
somatorio_betas_ponderados
```

## Retornos
```{r}
retorno_anual_carteira  <- mean(retornos_carteira_arit$ret_closing_prices)*252
retorno_anual_mercado <- mean(retornos_mercado_arit$ret_closing_prices)*252
selic  <- 0.105
retorno_esperado_carteira  <- selic + (retorno_anual_mercado - selic)*somatorio_ponderado_betas

print(paste0("Considerando taxa Selic de 10,5%, retorno anual do mercado (Ibovespa) de 6%, o retorno mínimo esperado da carteira é de ", round(retorno_esperado_carteira,2)*100,"%" ))
```

# Otimização da carteira
```{r}


# formatando para wide e transformando em formato objeto xts
portfolio_wide_xts  <-  portfolio %>% 
  spread(ticker, value = ret_closing_prices)  %>% 
    tk_xts()
# Retirando coluna de data
portfolio_wide_xts <- portfolio_wide_xts[,-7]
# Convertendo colunas para numéricas
portfolio_wide_xts <- apply(portfolio_wide_xts, 2, as.numeric)

numero_simulacoes_portfolio = 5000

todos_os_pesos  <- 
```

### Matriz covariância
```{r}
cov_mat <- cov(portfolio_wide_xts) * 252
print(round(cov_mat,4))
```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INSERIR INTERPRETAÇÃO AQUI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### Media de retornos
```{r}
media_retornos  <- colMeans(portfolio_wide_xts)
media_retornos
``` 

### Risco (Desvio Padrão)
```{r}
risco_portfolio  <- sqrt(t(pesos) %*% (cov_mat %*% pesos))
```

### Sharpe ratio
```{r}
sharpe_ratio  <- media_retornos / risco_portfolio
```